<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>1112917-FinalTerm</title>
  <style>
    /* --- CSS 樣式區域 --- */
    :root {
      --bg: #1a1c29;          /* 背景深色 */
      --board-bg: #dcb35c;    /* 棋盤木頭色 */
      --text: #e7e8ee;        /* 文字顏色 */
      --cell-size: 36px;      /* 交叉點大小 (動態調整) */
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: 'Noto Sans TC', system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }

    h1 { margin: 10px 0 10px 0; font-size: 28px; letter-spacing: 2px; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }

    /* --- 狀態列 --- */
    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(255, 255, 255, 0.08);
      padding: 15px 30px;
      border-radius: 50px;
      margin-bottom: 15px;
      width: 100%;
      max-width: 500px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }

    .player-info {
      display: flex;
      flex-direction: column;
      align-items: center;
      opacity: 0.5;
      transition: opacity 0.3s;
    }

    .player-info.active {
      opacity: 1;
      transform: scale(1.1);
    }

    .stone-icon {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      box-shadow: 0 2px 5px rgba(0,0,0,0.5);
      margin-bottom: 5px;
    }
    .stone-icon.black { background: #111; border: 2px solid #555; }
    .stone-icon.white { background: #fff; border: 2px solid #ccc; }

    .score-label { font-size: 12px; color: #aaa; }
    .live-count { font-size: 24px; font-weight: 800; color: #4dd0e1; } /* 改顏色突顯 */
    .vs { font-weight: bold; font-style: italic; color: #666; font-size: 20px; }

    /* --- 訊息與虛手提示 --- */
    .info-wrapper {
      text-align: center;
      margin-bottom: 15px;
    }

    .msg-area {
      color: #ffd700;
      font-size: 16px;
      font-weight: bold;
      letter-spacing: 1px;
      margin-bottom: 5px;
      min-height: 24px;
    }

    /* 新增：虛手計數器 */
    .pass-indicator {
      font-size: 13px;
      color: #aaa;
      background: rgba(0,0,0,0.3);
      padding: 4px 12px;
      border-radius: 10px;
      display: inline-block;
      transition: all 0.3s;
    }
    .pass-indicator.warning {
      color: #ff6b6b;
      background: rgba(255, 107, 107, 0.15);
      border: 1px solid rgba(255, 107, 107, 0.3);
    }

    /* --- 棋盤區域 --- */
    .board-wrapper {
      background: #222;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 20px 50px rgba(0,0,0,0.8);
    }

    .board {
      display: grid;
      background-color: var(--board-bg);
      border: 2px solid #000;
      position: relative;
      cursor: crosshair;
    }

    .intersection {
      width: var(--cell-size);
      height: var(--cell-size);
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* 畫線 */
    .intersection::before { content: ''; position: absolute; top: 50%; left: 0; width: 100%; height: 1px; background: #000; z-index: 0; }
    .intersection::after { content: ''; position: absolute; left: 50%; top: 0; height: 100%; width: 1px; background: #000; z-index: 0; }
    
    /* 星位 */
    .intersection.star::before { height: 4px; width: 4px; border-radius: 50%; background: #000; top: calc(50% - 2px); left: calc(50% - 2px); z-index: 1; }
    .intersection.star::after { display: none; }

    /* --- 棋子 --- */
    .stone {
      width: 85%;
      height: 85%;
      border-radius: 50%;
      position: relative;
      z-index: 10;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.4);
      transform: scale(0);
      animation: popIn 0.2s forwards;
    }
    .stone.black { background: radial-gradient(circle at 30% 30%, #555, #000); }
    .stone.white { background: radial-gradient(circle at 30% 30%, #fff, #ddd); }
    .stone.last-move::after { content: ''; position: absolute; width: 30%; height: 30%; background: rgba(255, 0, 0, 0.7); top: 35%; left: 35%; border-radius: 50%; }

    @keyframes popIn { to { transform: scale(1); } }

    /* --- 控制區 --- */
    .controls {
      margin-top: 25px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }

    button, select {
      padding: 10px 20px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.2);
      background: #2a305e;
      color: white;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }
    button:hover { background: #3b4275; transform: translateY(-2px); }
    
    button.pass-btn { background: #e57373; border-color: #ef5350; }
    button.pass-btn:hover { background: #ef5350; }

    /* 新增：返回首頁按鈕樣式 */
    button.home-btn { background: #4db6ac; border-color: #009688; }
    button.home-btn:hover { background: #26a69a; }

    /* --- 彈窗 --- */
    .modal {
      display: none;
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.85);
      z-index: 100;
      justify-content: center;
      align-items: center;
    }
    .modal.show { display: flex; }
    .modal-content {
      background: #1a1d3a;
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      border: 1px solid #444;
      max-width: 400px;
    }
    .modal-content h2 { color: #ffe066; }
    .modal-content p { color: #ccc; line-height: 1.6; }
    .modal-content button { margin-top: 10px; }

  </style>
</head>
<body>

  <h1>1112917-FinalTerm 圍棋對戰</h1>

  <div class="status-bar">
    <div class="player-info" id="p-black">
      <div class="stone-icon black"></div>
      <span class="score-label">盤面活棋</span>
      <span class="live-count" id="count-black">0</span>
    </div>
    <div class="vs">VS</div>
    <div class="player-info" id="p-white">
      <div class="stone-icon white"></div>
      <span class="score-label">盤面活棋</span>
      <span class="live-count" id="count-white">0</span>
    </div>
  </div>

  <div class="info-wrapper">
    <div class="msg-area" id="msg-area">輪到黑棋 (玩家) 下子</div>
    <div id="pass-indicator" class="pass-indicator">連續虛手: 0 / 2 (達 2 次即終局)</div>
  </div>

  <div class="board-wrapper">
    <div id="board" class="board"></div>
  </div>

  <div class="controls">
    <select id="board-size">
      <option value="9" selected>9路 (基礎)</option>
      <option value="13">13路 (標準)</option>
      <option value="19">19路 (專業)</option>
    </select>
    <button id="btn-pass" class="pass-btn">虛手 (Pass)</button>
    <button id="btn-restart">重開一局</button>
    <button onclick="location.href='index.html'" class="home-btn">返回首頁</button>
  </div>

  <div id="result-modal" class="modal">
    <div class="modal-content">
      <h2 id="modal-title">對局結束</h2>
      <p id="modal-msg"></p>
      <button onclick="closeModal()">關閉</button>
      <button onclick="initGame()">再來一局</button>
    </div>
  </div>

<script>
// --- JavaScript 邏輯 ---

const BLACK = 1; 
const WHITE = 2; 
const EMPTY = 0;

let boardState = []; 
let boardSize = 9; 
let currentPlayer = BLACK;
let prisoners = { [BLACK]: 0, [WHITE]: 0 }; // 仍需保留變數以供終局計算
let passCount = 0; 
let isGameActive = false;
let isComputerTurn = false;

// DOM 元素
const boardEl = document.getElementById('board');
const msgEl = document.getElementById('msg-area');
// 修改綁定對象為新的計分板
const countBlackEl = document.getElementById('count-black');
const countWhiteEl = document.getElementById('count-white');
const pBlackEl = document.getElementById('p-black');
const pWhiteEl = document.getElementById('p-white');
const passIndicatorEl = document.getElementById('pass-indicator');
const sizeSelect = document.getElementById('board-size');

function initGame() {
    boardSize = parseInt(sizeSelect.value);
    boardState = Array.from({ length: boardSize }, () => Array(boardSize).fill(EMPTY));
    currentPlayer = BLACK;
    prisoners = { [BLACK]: 0, [WHITE]: 0 };
    passCount = 0;
    isGameActive = true;
    isComputerTurn = false;
    
    closeModal();
    renderBoard();
    updateUI(); // 這會更新盤面子數為 0
    msgEl.textContent = "輪到黑棋 (玩家) 下子";
}

function renderBoard() {
    boardEl.innerHTML = '';
    boardEl.style.gridTemplateColumns = `repeat(${boardSize}, var(--cell-size))`;
    boardEl.style.gridTemplateRows = `repeat(${boardSize}, var(--cell-size))`;

    let newSize = boardSize === 9 ? 42 : (boardSize === 13 ? 34 : 26);
    document.documentElement.style.setProperty('--cell-size', `${newSize}px`);

    for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
            const intersection = document.createElement('div');
            intersection.className = 'intersection';
            intersection.dataset.r = r;
            intersection.dataset.c = c;
            
            if (isStarPoint(r, c, boardSize)) {
                intersection.classList.add('star');
            }
            intersection.onclick = () => handleInput(r, c);
            boardEl.appendChild(intersection);
        }
    }
}

function isStarPoint(r, c, size) {
    if (size === 9 && (r===2||r===6) && (c===2||c===6)) return true;
    if (size === 9 && r===4 && c===4) return true;
    if (size === 13 && (r===3||r===9) && (c===3||c===9)) return true;
    if (size === 13 && r===6 && c===6) return true;
    if (size === 19) {
        const stars = [3, 9, 15];
        return stars.includes(r) && stars.includes(c);
    }
    return false;
}

// --- 邏輯判定 ---

function isValidMove(r, c, player) {
    if (r < 0 || r >= boardSize || c < 0 || c >= boardSize) return false;
    if (boardState[r][c] !== EMPTY) return false; 

    const tempBoard = JSON.parse(JSON.stringify(boardState));
    tempBoard[r][c] = player;

    const opponent = player === BLACK ? WHITE : BLACK;
    const captured = findCaptures(tempBoard, r, c, opponent);
    if (captured.length > 0) return true;

    const liberties = countLiberties(tempBoard, r, c);
    if (liberties === 0) return false; 

    return true;
}

function countLiberties(board, r, c) {
    const group = getGroup(board, r, c);
    const liberties = new Set();
    group.forEach(pt => {
        const neighbors = [{r: pt.r-1, c: pt.c}, {r: pt.r+1, c: pt.c}, {r: pt.r, c: pt.c-1}, {r: pt.r, c: pt.c+1}];
        neighbors.forEach(n => {
            if (n.r >= 0 && n.r < boardSize && n.c >= 0 && n.c < boardSize) {
                if (board[n.r][n.c] === EMPTY) liberties.add(`${n.r},${n.c}`);
            }
        });
    });
    return liberties.size;
}

function getGroup(board, r, c) {
    const color = board[r][c];
    const group = [];
    const queue = [{r, c}];
    const visited = new Set();
    visited.add(`${r},${c}`);

    while (queue.length > 0) {
        const curr = queue.pop();
        group.push(curr);
        const neighbors = [{r: curr.r-1, c: curr.c}, {r: curr.r+1, c: curr.c}, {r: curr.r, c: curr.c-1}, {r: curr.r, c: curr.c+1}];
        neighbors.forEach(n => {
            if (n.r >= 0 && n.r < boardSize && n.c >= 0 && n.c < boardSize) {
                const key = `${n.r},${n.c}`;
                if (!visited.has(key) && board[n.r][n.c] === color) {
                    visited.add(key);
                    queue.push(n);
                }
            }
        });
    }
    return group;
}

function handleCaptures(r, c, player) {
    const opponent = player === BLACK ? WHITE : BLACK;
    const neighbors = [{r: r-1, c: c}, {r: r+1, c: c}, {r: r, c: c-1}, {r: r, c: c+1}];
    let totalCaptured = 0;

    neighbors.forEach(n => {
        if (n.r >= 0 && n.r < boardSize && n.c >= 0 && n.c < boardSize) {
            if (boardState[n.r][n.c] === opponent) {
                const libs = countLiberties(boardState, n.r, n.c);
                if (libs === 0) {
                    const group = getGroup(boardState, n.r, n.c);
                    group.forEach(stone => {
                        boardState[stone.r][stone.c] = EMPTY;
                        removeStoneVisual(stone.r, stone.c);
                        totalCaptured++;
                    });
                }
            }
        }
    });
    prisoners[player] += totalCaptured;
}

function findCaptures(board, r, c, targetColor) {
    const neighbors = [{r: r-1, c: c}, {r: r+1, c: c}, {r: r, c: c-1}, {r: r, c: c+1}];
    let captured = [];
    neighbors.forEach(n => {
        if (n.r >= 0 && n.r < boardSize && n.c >= 0 && n.c < boardSize) {
            if (board[n.r][n.c] === targetColor) {
                if (countLiberties(board, n.r, n.c) === 0) captured.push(n);
            }
        }
    });
    return captured;
}

// --- 介面操作 ---

function placeStoneVisual(r, c, player) {
    const cell = document.querySelector(`.intersection[data-r='${r}'][data-c='${c}']`);
    if (!cell) return;
    const oldStone = cell.querySelector('.stone');
    if (oldStone) oldStone.remove();
    const stone = document.createElement('div');
    stone.className = `stone ${player === BLACK ? 'black' : 'white'}`;
    cell.appendChild(stone);
    
    document.querySelectorAll('.last-move').forEach(el => el.classList.remove('last-move'));
    stone.classList.add('last-move');
}

function removeStoneVisual(r, c) {
    const cell = document.querySelector(`.intersection[data-r='${r}'][data-c='${c}']`);
    const stone = cell ? cell.querySelector('.stone') : null;
    if (stone) {
        stone.style.transform = 'scale(0)';
        setTimeout(() => stone.remove(), 200);
    }
}

function handleInput(r, c) {
    if (!isGameActive || isComputerTurn || boardState[r][c] !== EMPTY) return;
    if (isValidMove(r, c, BLACK)) {
        makeMove(r, c, BLACK);
    } else {
        alert("禁著點 (自殺手) 或位置無效");
    }
}

function makeMove(r, c, player) {
    boardState[r][c] = player;
    placeStoneVisual(r, c, player);
    passCount = 0; 
    
    handleCaptures(r, c, player);
    updateUI(); // 這裡會重新計算活棋數
    
    const nextPlayer = player === BLACK ? WHITE : BLACK;
    currentPlayer = nextPlayer;

    if (isGameActive && nextPlayer === WHITE) {
        isComputerTurn = true;
        msgEl.textContent = "電腦思考中...";
        setTimeout(computerAI, 500);
    } else {
        msgEl.textContent = "輪到黑棋 (玩家) 下子";
    }
}

function computerAI() {
    if (!isGameActive) return;

    let bestMove = null;
    let maxScore = -Infinity;
    const candidates = [];

    for(let r=0; r<boardSize; r++) {
        for(let c=0; c<boardSize; c++) {
            if (boardState[r][c] === EMPTY) {
                if (isValidMove(r, c, WHITE)) {
                    candidates.push({r, c});
                }
            }
        }
    }

    if (candidates.length === 0) {
        handlePass(); 
        return;
    }

    candidates.forEach(move => {
        let score = Math.random() * 10; 
        const tempBoard = JSON.parse(JSON.stringify(boardState));
        tempBoard[move.r][move.c] = WHITE;
        
        const caps = findCaptures(tempBoard, move.r, move.c, BLACK);
        if (caps.length > 0) score += 1000 + caps.length * 100;

        const libs = countLiberties(tempBoard, move.r, move.c);
        if (libs === 1) score -= 500; 
        if (libs >= 4) score += 50;

        if ((move.r === 2 || move.r === boardSize-3) || (move.c === 2 || move.c === boardSize-3)) score += 20;

        if (score > maxScore) {
            maxScore = score;
            bestMove = move;
        }
    });

    makeMove(bestMove.r, bestMove.c, WHITE);
    isComputerTurn = false;
}

function handlePass() {
    passCount++;
    const playerStr = currentPlayer === BLACK ? "黑棋" : "白棋";
    msgEl.textContent = `${playerStr} 選擇虛手 (Pass)`;

    // 更新 UI 虛手次數
    updateUI(); 

    if (passCount >= 2) {
        endGame();
        return;
    }

    currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;
    if (currentPlayer === WHITE) {
        isComputerTurn = true;
        setTimeout(computerAI, 800);
    } else {
        isComputerTurn = false;
        msgEl.textContent = "輪到黑棋 (玩家) 下子";
    }
}

function endGame() {
    isGameActive = false;
    
    // 計算活棋 (盤面上還存在的棋子)
    let blackStones = 0;
    let whiteStones = 0;
    for(let r=0; r<boardSize; r++){
        for(let c=0; c<boardSize; c++){
            if(boardState[r][c] === BLACK) blackStones++;
            else if(boardState[r][c] === WHITE) whiteStones++;
        }
    }

    // 分數判定 (使用盤面活棋 + 提子 + 貼目)
    const finalBlack = prisoners[BLACK] + blackStones;
    const finalWhite = prisoners[WHITE] + whiteStones + 6.5; 

    let msg = `雙方連續虛手，對局結束！<br><hr>`;
    msg += `<b>黑棋</b><br>活棋:${blackStones} + 提子:${prisoners[BLACK]} = <b>${finalBlack}</b><br><br>`;
    msg += `<b>白棋</b><br>活棋:${whiteStones} + 提子:${prisoners[WHITE]} + 貼目:6.5 = <b>${finalWhite}</b><br><hr>`;
    
    if (finalBlack > finalWhite) msg += "<span style='color:#ff6b6b; font-size:24px'>黑棋獲勝！</span>";
    else msg += "<span style='color:#4dd0e1; font-size:24px'>白棋獲勝！</span>";

    document.getElementById('modal-msg').innerHTML = msg;
    document.getElementById('result-modal').classList.add('show');
}

// 2. 更新統計資料與虛手狀態
function updateUI() {
    // 統計盤面活棋數
    let bCount = 0;
    let wCount = 0;
    for(let r=0; r<boardSize; r++){
        for(let c=0; c<boardSize; c++){
            if(boardState[r][c] === BLACK) bCount++;
            else if(boardState[r][c] === WHITE) wCount++;
        }
    }
    countBlackEl.innerText = bCount;
    countWhiteEl.innerText = wCount;

    // 顯示虛手狀態
    passIndicatorEl.textContent = `連續虛手: ${passCount} / 2 (達 2 次即終局)`;
    if (passCount > 0) {
        passIndicatorEl.classList.add('warning');
    } else {
        passIndicatorEl.classList.remove('warning');
    }

    if (currentPlayer === BLACK) {
        pBlackEl.classList.add('active');
        pWhiteEl.classList.remove('active');
    } else {
        pWhiteEl.classList.add('active');
        pBlackEl.classList.remove('active');
    }
}

function closeModal() {
    document.getElementById('result-modal').classList.remove('show');
}

// 事件綁定
document.getElementById('btn-restart').onclick = initGame;
document.getElementById('btn-pass').onclick = () => {
    if(isGameActive && !isComputerTurn) handlePass();
};
sizeSelect.onchange = initGame;

initGame();

</script>
</body>
</html>
